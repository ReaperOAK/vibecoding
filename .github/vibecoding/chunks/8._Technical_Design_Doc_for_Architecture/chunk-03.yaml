---
source: "./.github/instructions/SDLC/8. Technical Design Doc for Architecture.md"
chunk_index: 3
token_estimate: 3749
hash: "5a08c5779ec8e4948bdd0281fd30df997a5c3407034e63601c02406b26adfd53"
summary: "The API Contract is the formal, unambiguous definition of an API. It is a machine-readable file, typically written in..."
---
The API Contract is the formal, unambiguous definition of an API. It is a machine-readable file, typically written in a specification language like OpenAPI (for REST APIs) or AsyncAPI (for event-driven APIs), that serves as the single source of truth for both the API provider and its consumers.1 Frontend and backend teams can develop in parallel against this contract, confident that their work will integrate correctly.12

The design of the API Contract should not happen in a vacuum. The Sequence Diagram serves as the dynamic model that validates the API's behavior in a real-world scenario. The best practice is to first create a Sequence Diagram to "act out" the API calls required to fulfill a user story. This process of visualizing the interaction flow directly informs and validates the creation of the endpoints, request payloads, and response structures defined in the formal API Contract. For example, a message from a Frontend lifeline to a Backend lifeline labeled POST /orders (OrderData) in a sequence diagram directly translates to an OpenAPI specification for a /orders path with a post operation and a request body schema matching OrderData. The TDD should present the Sequence Diagram and the API Contract together, using the diagram to explain and justify the design of the contract.

A well-designed API contract adheres to established conventions, making it predictable, intuitive, and easy for developers to use. For RESTful APIs, these conventions are critical.

| Principle | Best Practice | Example |
| :---- | :---- | :---- |
| **Resource Naming** | Use plural nouns for collection URIs. Avoid verbs in URIs. | GET /users (Good) vs. GET /getAllUsers (Bad) |
| **HTTP Methods** | Use HTTP methods to specify the action: GET (read), POST (create), PUT/PATCH (update), DELETE (remove). | POST /users to create a new user. |
| **Status Codes** | Use standard HTTP status codes to indicate the outcome of a request. | 200 OK, 201 Created, 400 Bad Request, 404 Not Found, 500 Internal Server Error |
| **Hierarchy** | Use a logical hierarchy for related resources, but keep it shallow (no more than collection/item/collection). | /customers/123/orders (Good) vs. /customers/123/orders/99/products/456 (Too complex) |
| **Versioning** | Include the version in the URI to manage changes and avoid breaking existing clients. | /api/v1/users |
| **Error Handling** | Provide a consistent, detailed error payload for 4xx and 5xx responses to help clients debug. | { "error": "InvalidEmailFormat", "message": "The provided email address is not valid." } |

12

## **Part III: The Art of Crafting the TDD: Process and Tactics**

Creating a high-quality TDD involves more than just technical modeling; it requires a disciplined process, strong communication skills, and a collaborative mindset. This section focuses on the practical tactics for writing, reviewing, and maintaining a TDD that serves as a valuable asset throughout the project lifecycle.

### **3.1 The TDD Lifecycle: From Draft to Living Document**

The TDD is not a static artifact created at a single point in time. It is a living document that evolves with the project and serves as a continuous reference point for the engineering team.

* **The Process:** The creation of a TDD is a distinct step in the SDLC that follows the definition of product and business requirements (the "what") and precedes implementation (the "build").4 Its purpose is to translate those requirements into a concrete technical solution (the "how"). This process should begin as soon as the functional requirements are stable enough to allow for technical design.  
* **Start with a Template:** To ensure consistency across projects and to prevent critical sections from being omitted, the creation process should always begin with a standardized company template, such as the one detailed in Part I.4 This provides a structured framework and prompts the author to consider all necessary aspects of the design.  
* **Iterate and Refine:** The initial draft of a TDD is rarely the final version. The document should be developed iteratively. An initial version might contain high-level architecture and open questions, which are then filled in and refined as design decisions are made and reviewed. This iterative process allows the design to mature based on feedback and deeper investigation.2  
* **The Goal of Sufficiency:** The ultimate goal for a TDD is to achieve a state of "sufficiency." This means the document must be thorough and detailed enough that another competent engineer, who was not involved in the design process, could read it and implement the system as intended without needing to consult the original author.4 This is the litmus test for a complete and effective TDD.  
* **Versioning and Maintenance:** Once approved, the TDD becomes a foundational document for the project. However, it must be kept up-to-date. If design decisions change during implementation, the TDD must be updated to reflect the final state of the system. An outdated TDD is more dangerous than no TDD at all, as it provides misleading information to future developers. Implementing a versioning system for the document is a best practice for tracking changes over time.7

### **3.2 The Language of Design: Writing with Clarity and Precision**

The quality of the writing in a TDD is as important as the quality of the technical design it describes. A brilliant design communicated poorly is unlikely to be implemented correctly.

* **Know Your Audience:** The primary audience for a TDD consists of fellow engineers who will build, test, and maintain the system. The writing should be tailored to this audienceâ€”precise, unambiguous, and technically sound. While it's important to avoid overly complex jargon where simpler terms suffice, the author should not shy away from necessary technical language. Any specialized or domain-specific terms must be clearly defined in the glossary to ensure a shared understanding.2  
* **Use Clear, Simple Language:** Clarity is paramount. Prefer short, direct sentences over long, convoluted ones. Use the active voice (e.g., "The service validates the input") rather than the passive voice (e.g., "The input is validated by the service"), as it is more direct and easier to understand.2 The tone should be professional but can also be conversational to improve readability.  
* **Structure for Scannability:** Engineers and other stakeholders are often short on time. They need to be able to quickly find the information they are looking for. To facilitate this, the document must be structured for scannability. This involves using:  
  * A clear hierarchy of headings and subheadings.  
  * Bulleted and numbered lists for sequences or collections of items.  
  * Short paragraphs that focus on a single idea.  
  * Ample white space to prevent the page from looking like a dense "wall of text".7  
* **Leverage Visuals:** Diagrams are not just content to be included; they are a powerful tool for communication. Complex concepts, relationships, and flows are often better explained with a diagram than with paragraphs of text. Use diagrams, flowcharts, and tables to illustrate and simplify complex parts of the design. Every diagram should be accompanied by a caption and explanatory text that guides the reader in its interpretation.2

### **3.3 Collaborative Design: Facilitating Reviews and Incorporating Feedback**

A TDD should never be created in a silo. The design process is a collaborative activity that leverages the collective expertise of the team to produce a more robust and well-vetted solution.

* **The TDD as a Team Sport:** The document should be treated as a shared artifact. Using collaborative platforms like Confluence or Google Docs, which support real-time editing and commenting, is highly recommended. This allows team members to provide feedback directly on the document, fostering discussion and ensuring all perspectives are considered.2  
* **Formal Design Reviews:** The TDD must undergo a formal review process before it is approved and implementation begins. This review should involve other senior engineers, the tech lead, and potentially architects or representatives from other affected teams (e.g., DevOps, Security). The purpose of the review is to challenge assumptions, identify potential flaws, and ensure the design is sound, scalable, and aligns with broader technical standards. This process is one of the most effective ways to catch costly errors before a single line of code is written.  
* **Facilitating Workshops:** For particularly complex or contentious aspects of the design, such as defining system boundaries or critical API interfaces, it can be highly effective to facilitate dedicated workshops. These focused sessions bring together all relevant stakeholders (engineers, product managers, QA) to discuss, debate, and agree upon a solution in real-time. The outcomes of these workshops are then documented in the TDD, ensuring alignment and buy-in from everyone involved.9

## **Part IV: Avoiding Common Pitfalls in Technical Design**

While following best practices is crucial, it is equally important to be aware of common mistakes that can undermine the value and effectiveness of a Technical Design Document. Recognizing and avoiding these pitfalls is a hallmark of an experienced and disciplined engineering team.

### **4.1 The Seven Sins of TDD Authoring**

These seven common mistakes represent the most frequent ways in which TDDs fail to achieve their strategic purpose.

* **1\. Ambiguity and Vagueness:** Using imprecise language, undefined acronyms, or unclear terminology. A TDD must be a document of precision. Phrases like "the system should be fast" are useless without specific, measurable targets. Every statement should be verifiable and unambiguous.41  
* **2\. Analysis Paralysis (Too Much Detail):** In an attempt to be thorough, authors can provide an overwhelming amount of irrelevant detail. This makes the document difficult to read and can delay the project unnecessarily. The TDD should focus on the information essential for implementation, not every minor detail of every possible implementation choice. The goal is clarity, not exhaustive verbosity.41  
* **3\. Insufficient Detail (Too Vague):** The opposite but equally damaging sin. A TDD that is too high-level and leaves critical questions unanswered forces developers to make design decisions on the fly during implementation. This defeats the purpose of the design phase and leads to inconsistent, poorly considered outcomes. A good TDD should answer more questions than it creates.41  
* **4\. Poor Organization:** A document that lacks a logical structure is nearly impossible to follow. Jumping between high-level architecture, low-level data definitions, and business logic without clear headings and a coherent flow will confuse the reader and obscure the design. Adhering to a standard template is the best defense against this.40  
* **5\. Ignoring the "Why":** A TDD that only documents the "what" and "how" of a design is incomplete. It must also explain the "why." This includes documenting the rationale behind key decisions and, crucially, the alternatives that were considered and rejected. Without this context, future teams maintaining the system will not understand the original design intent and may inadvertently make changes that violate key architectural principles.4  
* **6\. The "Write Once, Never Update" Fallacy:** Treating the TDD as a one-time, disposable artifact that is forgotten after the project kickoff. A TDD that does not reflect the final, as-built state of the system is worse than having no document at all, because it is actively misleading. The TDD must be a living document, updated throughout the project lifecycle.2  
* **7\. The Silo Effect:** Writing the TDD in isolation without seeking input and feedback from the rest of the team. This almost always results in a design that is either impractical, not well understood by those who must implement it, or misaligned with the project's true requirements. Design is a collaborative process, and the TDD is the record of that collaboration.40

### **4.2 A Checklist for TDD Excellence**

Before a TDD is given final approval, it should be evaluated against a simple checklist to ensure it meets the standards of quality required for a production-grade system. This checklist can be used by the author for self-review or by the designated reviewers.

* **Clarity:**  
  * Is the problem statement and rationale clear and compelling?  
  * Are the goals specific, measurable, and relevant?  
  * Is all technical jargon, and are all acronyms defined in a glossary?  
  * Is the language unambiguous and written in a simple, active voice?  
* **Completeness:**  
  * Does the document include all sections from the standard template?  
  * Are all required diagrams from the SDLC process (Use Case, Activity, DFD, Class, ERD, Sequence) present?  
  * Are cross-cutting concerns like security, performance, and operations adequately addressed?  
  * Are alternatives, risks, and open questions documented?  
* **Coherence:**  
  * Does the document tell a logical and consistent story from problem to solution?  
  * Do the detailed diagrams and specifications align with the high-level architecture?  
  * Do the visual diagrams effectively support and clarify the text?  
* **Correctness:**  
  * Are the diagrams technically sound and do they use correct, standard notation?  
  * Is the proposed solution technically feasible within the project's constraints?  
  * Have the potential impacts on existing systems been correctly identified?  
* **Consensus:**  
  * Has the document been formally reviewed by the required peers and stakeholders?  
  * Have all significant comments and questions from the review process been addressed?  
  * Is there a clear alignment and agreement among the core team on the proposed technical approach?

## **Conclusion**

The Technical Design Document is far more than a procedural formality or an exercise in creating diagrams. It is the single most important artifact in the effort to build robust, scalable, and maintainable software. When executed with rigor and a strategic mindset, the TDD acts as the central nervous system of a project, connecting business requirements to architectural decisions and technical implementation. It is a tool for risk mitigation, a catalyst for team alignment, and a durable record of the critical thinking that underpins a software system.

A successful TDD is born from a process that values clarity over complexity, collaboration over isolation, and disciplined iteration over static pronouncements. It requires a blend of deep technical expertise in modeling system structures and behaviors, strong communication skills to articulate complex ideas simply, and a commitment to a collaborative review process that ensures the final design is well-vetted and understood by all.
