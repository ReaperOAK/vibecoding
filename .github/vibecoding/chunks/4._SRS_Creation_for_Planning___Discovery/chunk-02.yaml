---
source: "./.github/instructions/SDLC/4. SRS Creation for Planning & Discovery.md"
chunk_index: 2
token_estimate: 3807
hash: "d233e2ab988c41deed9aa5b4134742cbbe236b13af41780bf965cacc71039803"
summary: "* **Reliability and Availability:** This measures the system's stability and uptime. It is typically expressed as a p..."
---
* **Reliability and Availability:** This measures the system's stability and uptime. It is typically expressed as a percentage: "The system shall achieve 99.9% uptime, measured on a monthly basis".11  
* **Usability:** This relates to the ease with which users can interact with the system. It can be quantified by defining a measurable task-completion goal: "A new user must be able to complete the registration process in under 90 seconds without assistance".16  
* **Maintainability and Portability:** These define requirements for the ease of modifying the system and moving it to different environments.11

#### **2.3.3 External Interface Requirements**

This section provides a detailed description of all inputs into and outputs from the software system. It separates them into four categories:

* **User Interfaces:** Describes the logical characteristics of each user interface. This is not a detailed UI design but a specification of screen layouts, buttons, navigation, and other user-facing elements required to support the functional requirements.  
* **Hardware Interfaces:** Specifies the logical and physical characteristics of each interface between the software and the hardware components of the system.  
* **Software Interfaces:** Describes the connections between this system and other software components, including other applications, operating systems, or databases. This is where API contracts are defined, for example: "The system will integrate with the Stripe payment gateway via their specified REST API".5  
* **Communications Interfaces:** Details the requirements for any communication functions required by the software, such as network protocols, data transfer rates, and security protocols for communication.

## **Section 3: The Requirements Engineering Process: From Conversation to Specification**

Creating a high-quality SRS is not a solitary writing task but a structured engineering process involving multiple stages and stakeholders. This process transforms abstract ideas and stakeholder needs into a formal, actionable specification. Adhering to this process ensures that the resulting document is complete, correct, and has the buy-in of the entire project team.

### **3.1 Step 1: Stakeholder Identification and Analysis**

The foundational step in requirements engineering is to identify all relevant stakeholders. A stakeholder is any individual or group who is affected by the project, has influence over it, or has an interest in its success.17 This list must be comprehensive, including:

* **End-Users:** The people who will interact with the software daily.  
* **Customers:** The individuals or organizations paying for the project.  
* **Internal Teams:** Developers, QA testers, project managers, system architects, UI/UX designers.  
* **Business Stakeholders:** Representatives from marketing, sales, legal, and executive management who have business goals tied to the product.18

A common and critical error is to neglect the input of "low-level" end-users in favor of management perspectives. These users possess invaluable ground-level knowledge about current workflows and pain points. Ignoring their input often results in software that is technically functional but difficult to adopt, leading to requests for major and costly changes after launch.17

### **3.2 Step 2: Requirements Elicitation Masterclass (The Gathering Process)**

Requirements are not simply "gathered" like items in a basket; they must be actively elicited, discovered, and uncovered. Because different stakeholders and situations call for different approaches, it is best to use a "toolbox" of techniques rather than relying on a single method.21

* **Stakeholder Interviews:** This is the most powerful and common technique. One-on-one or small-group interviews allow for in-depth discussions to explore complex requirements, uncover hidden assumptions, and understand the nuances of user pain points.19 A successful interview process involves three stages: first, focusing solely on understanding the *problem* and the current state; second, translating that problem into potential solutions offline; and third, presenting those proposed solutions back to the stakeholders for feedback and refinement.24 The questions asked should be open-ended, focusing on the "who, what, where, when, why, and how" of each feature or process.25  
* **Workshops and Brainstorming Sessions:** These collaborative meetings bring together diverse groups of stakeholders to generate ideas, define requirements, and build consensus in real-time.17 They are particularly effective for resolving conflicting viewpoints and fostering a sense of shared ownership.  
* **Surveys and Questionnaires:** When input is needed from a large or geographically dispersed group of stakeholders, surveys provide an efficient method for collecting structured information and identifying common trends or needs.22  
* **Document Analysis:** Existing artifacts such as business plans, process diagrams, market research reports, and manuals for legacy systems can be a rich source of requirements and constraints.22  
* **Observation (Job Shadowing):** Sometimes, what users *say* they do and what they *actually* do are different. Observing users as they perform their daily tasks in their natural environment can reveal inefficiencies and unstated requirements that would never be discovered in an interview.22  
* **Prototyping and Mockups:** Creating simplified visual representations of the proposed software (from low-fidelity wireframes to interactive mockups) is an extremely effective elicitation technique. Prototypes make abstract ideas concrete, allowing stakeholders to provide specific, actionable feedback and helping to confirm the development team's understanding of the requirements before any code is written.17

This elicitation phase is fundamentally a process of negotiation. Stakeholders will inevitably have competing priorities and conflicting requirements (e.g., Marketing requires a feature for a Q3 launch, while Engineering identifies technical complexities that push the timeline to Q4). The role of the business analyst or product manager is not merely to record these requests but to facilitate a negotiation. They must guide the stakeholders toward a prioritized, feasible, and aligned set of requirements that serves the overarching business goals. The final SRS document represents the outcome of this negotiation—a documented consensus that all parties have agreed to.

### **3.3 Step 3: Analysis, Translation, and Documentation**

The raw data collected during elicitation—interview transcripts, workshop notes, survey results—must be analyzed and translated into the formal structure of the SRS document. This involves:

* **Synthesizing Information:** Identifying common themes, patterns, and key requirements from the various sources.  
* **Resolving Conflicts:** Documenting and addressing any contradictions between the needs of different stakeholders.  
* **Decomposition:** Breaking down high-level, abstract business needs into specific, detailed, and testable functional and non-functional requirements.26  
* **Populating the SRS:** Systematically filling out the sections of the SRS template (as defined in Section 2\) with these refined requirement statements.

### **3.4 Step 4: The Review and Approval Cycle**

The draft SRS is a proposal, not a final document. It must undergo a rigorous review and validation process with all key stakeholders to ensure its accuracy and completeness.17 This is an iterative cycle:

1. The draft SRS is circulated to the review team.  
2. Stakeholders provide feedback, ask for clarifications, and identify gaps or errors. This is the stage where they "poke holes" in the proposed requirements.24  
3. The document author incorporates the feedback, refines the requirements, and produces a new version.  
4. This cycle repeats until a consensus is reached and all parties agree that the document accurately reflects the project's needs.

The process concludes with a formal sign-off or approval from key stakeholders. This approved SRS then becomes the official project baseline, the single source of truth against which all future design, development, and testing activities will be measured.27

## **Section 4: Mastering the Language of Requirements: A Tactical Guide to Writing**

The effectiveness of an SRS hinges on the quality of its individual requirement statements. Writing clear, precise, and unambiguous requirements is a skill that combines technical understanding with disciplined communication. This section provides actionable tactics and best practices for mastering this craft.

### **4.1 The Hallmarks of a High-Quality Requirement**

Every requirement statement, whether functional or non-functional, should be evaluated against a set of quality characteristics. A well-written requirement is:

* **Unambiguous:** It has only one possible interpretation. All readers, regardless of their background, should understand it to mean the same thing.28  
* **Verifiable (or Testable):** There must be a feasible and objective way to determine whether the requirement has been met. This means avoiding subjective and qualitative terms like "fast," "easy to use," or "user-friendly".28  
* **Consistent:** It must not conflict with any other requirement in the SRS or with higher-level business rules or project goals.28  
* **Complete:** It should fully describe the necessary functionality, leaving no information for the developer to guess or infer. It must contain all the information needed to design and test that feature.4  
* **Traceable:** It should be uniquely identified with a persistent number or tag, allowing it to be traced forward to design elements and test cases, and backward to its source (e.g., a business objective or stakeholder request).5  
* **Implementation-Neutral:** It should define *what* the system must do, not *how* it should be implemented. Prescribing a technical solution (e.g., "use a dropdown menu") prematurely constrains the design and development teams.26

### **4.2 Writing Functional Requirements: Precision and Clarity**

To achieve the qualities listed above, functional requirements should be written with disciplined language and structure.

* **Use Standardized Language:** Establish a consistent vocabulary. The word "shall" is the industry standard for denoting a mandatory, binding requirement. Words like "should" or "may" can be used to indicate goals or optional features, but their use should be clearly defined in the document's introduction.30  
* **Write in the Active Voice:** The active voice is clearer and more direct. For example, "The system shall validate the user's email address" is superior to the passive "The user's email address shall be validated by the system".30  
* **Structure with User Stories and Acceptance Criteria:** While the formal SRS requirement is the ultimate goal, starting with a user story ("As a \[user type\], I want to \[perform some action\], so that I can \[achieve some goal\]") provides essential context about the user's motivation.23 Each requirement or user story must then be paired with a set of acceptance criteria. These are the specific, testable conditions that must be met for the requirement to be considered complete.20

The inclusion of acceptance criteria is not just a best practice; it is the mechanism that makes a requirement truly verifiable. It forms a direct bridge between the requirements defined in the SRS and the test cases that will be executed in the QA phase. By writing acceptance criteria during the discovery phase, the team is proactively designing the verification plan before development even begins, ensuring a seamless and traceable link from specification to validation.

### **4.3 Quantifying Quality: Writing Testable Non-Functional Requirements (NFRs)**

The most common failure in requirements writing is the inability to define NFRs in a measurable way. Vague quality goals are untestable and therefore unenforceable. The key is to transform every subjective quality into an objective, quantifiable metric. The following table provides a checklist and examples for writing effective NFRs.

| NFR Category | Common Vague Requirement (The Pitfall) | Measurable SRS Requirement (The Solution) |
| :---- | :---- | :---- |
| **Performance** | "The system should have a fast response time." | "The system shall render the user dashboard within 2 seconds for 95% of requests under a peak load of 500 concurrent users." |
| **Security** | "The system must be secure and protect user data." | "The system shall encrypt all Personally Identifiable Information (PII) at rest using AES-256. All user authentication tokens must expire after 24 hours." |
| **Reliability/Availability** | "The system should be highly available." | "The system shall achieve 99.95% uptime, excluding scheduled weekly maintenance windows of 2 hours (Saturday 2:00 AM \- 4:00 AM UTC)." |
| **Usability** | "The application must be user-friendly." | "A new user must be able to successfully complete the 'Create New Project' workflow in under 3 minutes without accessing help documentation." |
| **Scalability** | "The system should be able to handle future growth." | "The system architecture must support horizontal scaling to handle a 50% increase in user traffic year-over-year with no degradation in performance baselines." |
| **Maintainability** | "The code should be easy to maintain." | "The system shall adhere to the company's official Python style guide (PEP 8), and all new code must achieve a cyclomatic complexity score of 10 or less." |

### **4.4 The Power of Visuals: Augmenting Text with Diagrams**

Text alone is often insufficient for describing complex behavior, workflows, or system interactions. Visual models are essential for providing clarity and a shared understanding among stakeholders. The SRS should not exist in a vacuum; it should incorporate or reference key diagrams created during the discovery and design processes.1 Essential diagrams include:

* **Use Case Diagrams:** Visually map the interactions between external "actors" (users or other systems) and the features (use cases) of the system.  
* **Activity Diagrams:** Model complex business logic or user workflows step-by-step, including branches, loops, and parallel activities.  
* **Sequence Diagrams:** Illustrate the time-ordered sequence of messages exchanged between different objects or components to accomplish a specific task, making them ideal for detailing API interactions.  
* **Entity-Relationship Diagrams (ERDs):** Provide the logical blueprint for the database, showing all data entities (tables) and the relationships between them.5

## **Section 5: Navigating the Pitfalls: Common Mistakes and Proactive Avoidance**

Even with a solid process and template, several common pitfalls can undermine the quality and effectiveness of an SRS. Recognizing these mistakes is the first step toward proactively avoiding them. These pitfalls are often interconnected, creating a vicious cycle where one error leads to another, ultimately resulting in project delays and failures.

### **5.1 Ambiguity: The Root of All Evil**
