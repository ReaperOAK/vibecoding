---
source: "./.github/instructions/github-actions-ci-cd-best-practices.instructions.md"
chunk_index: 4
token_estimate: 1704
hash: "fccd95f21ed56946b68ff0c8f9fc67643b98bf145e415078ce6be849ac26102a"
summary: "- **Root Causes:** Incorrect cache key logic, `path` mismatch, cache size   limits, or frequent cache invalidation. -..."
---
- **Root Causes:** Incorrect cache key logic, `path` mismatch, cache size
  limits, or frequent cache invalidation.
- **Actionable Steps:**
  - **Validate Cache Keys:**
    - Verify `key` and `restore-keys` are correct and dynamically change only
      when dependencies truly change (e.g.,
      `key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}`). A
      cache key that is too dynamic will always result in a miss.
    - Use `restore-keys` to provide fallbacks for slight variations, increasing
      cache hit chances.
  - **Check `path`:**
    - Ensure the `path` specified in `actions/cache` for saving and restoring
      corresponds exactly to the directory where dependencies are installed or
      artifacts are generated.
    - Verify the existence of the `path` before caching.
  - **Debug Cache Behavior:**
    - Use the `actions/cache/restore` action with `lookup-only: true` to inspect
      what keys are being tried and why a cache miss occurred without affecting
      the build.
    - Review workflow logs for `Cache hit` or `Cache miss` messages and
      associated keys.
  - **Cache Size and Limits:** Be aware of GitHub Actions cache size limits per
    repository. If caches are very large, they might be evicted frequently.

### **4. Long Running Workflows or Timeouts**

- **Root Causes:** Inefficient steps, lack of parallelism, large dependencies,
  unoptimized Docker image builds, or resource bottlenecks on runners.
- **Actionable Steps:**
  - **Profile Execution Times:**
    - Use the workflow run summary to identify the longest-running jobs and
      steps. This is your primary tool for optimization.
  - **Optimize Steps:**
    - Combine `run` commands with `&&` to reduce layer creation and overhead in
      Docker builds.
    - Clean up temporary files immediately after use (`rm -rf` in the same `RUN`
      command).
    - Install only necessary dependencies.
  - **Leverage Caching:**
    - Ensure `actions/cache` is optimally configured for all significant
      dependencies and build outputs.
  - **Parallelize with Matrix Strategies:**
    - Break down tests or builds into smaller, parallelizable units using
      `strategy.matrix` to run them concurrently.
  - **Choose Appropriate Runners:**
    - Review `runs-on`. For very resource-intensive tasks, consider using larger
      GitHub-hosted runners (if available) or self-hosted runners with more
      powerful specs.
  - **Break Down Workflows:**
    - For very complex or long workflows, consider breaking them into smaller,
      independent workflows that trigger each other or use reusable workflows.

### **5. Flaky Tests in CI (`Random failures`, `Passes locally, fails in CI`)**

- **Root Causes:** Non-deterministic tests, race conditions, environmental
  inconsistencies between local and CI, reliance on external services, or poor
  test isolation.
- **Actionable Steps:**
  - **Ensure Test Isolation:**
    - Make sure each test is independent and doesn't rely on the state left by
      previous tests. Clean up resources (e.g., database entries) after each
      test or test suite.
  - **Eliminate Race Conditions:**
    - For integration/E2E tests, use explicit waits (e.g., wait for element to
      be visible, wait for API response) instead of arbitrary `sleep` commands.
    - Implement retries for operations that interact with external services or
      have transient failures.
  - **Standardize Environments:**
    - Ensure the CI environment (Node.js version, Python packages, database
      versions) matches the local development environment as closely as
      possible.
    - Use Docker `services` for consistent test dependencies.
  - **Robust Selectors (E2E):**
    - Use stable, unique selectors in E2E tests (e.g., `data-testid` attributes)
      instead of brittle CSS classes or XPath.
  - **Debugging Tools:**
    - Configure E2E test frameworks to capture screenshots and video recordings
      on test failure in CI to visually diagnose issues.
  - **Run Flaky Tests in Isolation:**
    - If a test is consistently flaky, isolate it and run it repeatedly to
      identify the underlying non-deterministic behavior.

### **6. Deployment Failures (Application Not Working After Deploy)**

- **Root Causes:** Configuration drift, environmental differences, missing
  runtime dependencies, application errors, or network issues post-deployment.
- **Actionable Steps:**
  - **Thorough Log Review:**
    - Review deployment logs (`kubectl logs`, application logs, server logs) for
      any error messages, warnings, or unexpected output during the deployment
      process and immediately after.
  - **Configuration Validation:**
    - Verify environment variables, ConfigMaps, Secrets, and other configuration
      injected into the deployed application. Ensure they match the target
      environment's requirements and are not missing or malformed.
    - Use pre-deployment checks to validate configuration.
  - **Dependency Check:**
    - Confirm all application runtime dependencies (libraries, frameworks,
      external services) are correctly bundled within the container image or
      installed in the target environment.
  - **Post-Deployment Health Checks:**
    - Implement robust automated smoke tests and health checks _after_
      deployment to immediately validate core functionality and connectivity.
      Trigger rollbacks if these fail.
  - **Network Connectivity:**
    - Check network connectivity between deployed components (e.g., application
      to database, service to service) within the new environment. Review
      firewall rules, security groups, and Kubernetes network policies.
  - **Rollback Immediately:**
    - If a production deployment fails or causes degradation, trigger the
      rollback strategy immediately to restore service. Diagnose the issue in a
      non-production environment.

## Conclusion

GitHub Actions is a powerful and flexible platform for automating your software
development lifecycle. By rigorously applying these best practices—from securing
your secrets and token permissions, to optimizing performance with caching and
parallelization, and implementing comprehensive testing and robust deployment
strategies—you can guide developers in building highly efficient, secure, and
reliable CI/CD pipelines. Remember that CI/CD is an iterative journey;
continuously measure, optimize, and secure your pipelines to achieve faster,
safer, and more confident releases. Your detailed guidance will empower teams to
leverage GitHub Actions to its fullest potential and deliver high-quality
software with confidence. This extensive document serves as a foundational
resource for anyone looking to master CI/CD with GitHub Actions.

---

<!-- End of GitHub Actions CI/CD Best Practices Instructions -->
